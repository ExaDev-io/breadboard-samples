[
  {
    "url": "https://developer.chrome.com/blog/introducing-scheduler-yield-origin-trial/",
    "title": "Introducing the scheduler.yield origin trial",
    "blog": "Building websites that respond quickly to user input has been one of the most challenging aspects of web performance—one that the Chrome Team has been working hard to help web developers meet. Just this year, it was announced that the Interaction to Next Paint (INP) metric would graduate from experimental to pending status. It is now poised to replace First Input Delay (FID) as a Core Web Vital in March of 2024.In a continued effort to deliver new APIs that help web developers make their websites as snappy as they can be, the Chrome Team is currently running an origin trial for scheduler.yield starting in version 115 of Chrome. scheduler.yield is a proposed new addition to the scheduler API that allows for both an easier and better way to yield control back to the main thread than the methods that have been traditionally relied upon.# On yieldingJavaScript uses the run-to-completion model to deal with tasks. This means that, when a task runs on the main thread, that task runs as long as necessary in order to complete. Upon a task's completion, control is yielded back to the main thread, which allows the main thread to process the next task in the queue.Aside from extreme cases when a task never finishes—such as an infinite loop, for example—yielding is an inevitable aspect of JavaScript's task scheduling logic. It will happen, it's just a matter of when, and sooner is better than later. When tasks take too long to run—greater than 50 milliseconds, to be exact—they are considered to be long tasks.Long tasks are a source of poor page responsiveness, because they delay the browser's ability to respond to user input. The more often long tasks occur—and the longer they run—the more likely it is that users may get the impression that the page is sluggish, or even feel that it's altogether broken.However, just because your code kicks off a task in the browser doesn't mean you have to wait until that task is finished before control is yielded back to the main thread. You can improve responsiveness to user input on a page by yielding explicitly in a task, which breaks the task up to be finished at the next available opportunity. This allows other tasks to get time on the main thread sooner than if they had to wait for long tasks to finish.A visualization of yielding control back to the main thread. At top, yielding occurs only after a task runs to completion, which means tasks can take longer to complete before returning control back to the main thread. At bottom, yielding is done explicitly, breaking up a long task into several smaller ones. This allows user interactions to run sooner, which improves input responsiveness and INP.When you explicitly yield, you're telling the browser \"hey, I understand that the work I'm about to do could take a while, and I don't want you to have to do all of that work before responding to user input or other tasks that might be important, too\". It's a valuable tool in a developer's toolbox that can go a long way towards improving the user experience.# The problem with current yielding strategiesImportantIf you're already familiar with current yielding methods—such as using setTimeout—you can jump straight to the section about scheduler.yield.A common method of yielding uses setTimeout with a timeout value of 0. This works because the callback passed to setTimeout will move the remaining work to a separate task that will be queued for subsequent execution. Rather than waiting for the browser to yield on its own, you're saying \"let's break this big chunk of work up into smaller bits\".However, yielding with setTimeout carries a potentially undesirable side effect: the work that comes after the yield point will go to the back of the task queue. Tasks scheduled by user interactions will still go to the front of the queue as they should—but the remaining work you wanted to do after explicitly yielding could end up being further delayed by other tasks from competing sources that were queued ahead of it.To see this in action, try out this Glitch demo—or experiment with it in the embedded version below. The demo consists of a few buttons you can click, and a box beneath them that logs when tasks are run. When you land on the page, perform the following actions:Click the top button labeled Run tasks periodically, which will schedule blocking tasks to run every so often. When you click this button, the task log will populate with several messages that read Ran blocking task with setInterval.Next, click the button labeled Run loop, yielding with setTimeout on each iteration.The source code for this demo is available if you want to dig further into what's going on.You'll notice that the box at the bottom of the demo will read something like this:Processing loop item 1Processing loop item 2Ran blocking task via setIntervalProcessing loop item 3Ran blocking task via setIntervalProcessing loop item 4Ran blocking task via setIntervalProcessing loop item 5Ran blocking task via setIntervalRan blocking task via setIntervalThis output demonstrates the \"end of task queue\" behavior that occurs when yielding with setTimeout. The loop that runs processes five items, and yields with setTimeout after each one has been processed.This illustrates a common problem on the web: it's not unusual for a script—particularly a third-party script—to register a timer function that runs work on some interval. The \"end of task queue\" behavior that comes with yielding with setTimeout means that work from other task sources may get queued ahead of the remaining work that the loop has to do after yielding.Depending on your application, this may or may not be a desirable outcome—but in many cases, this behavior is why developers may feel reluctant to give up control of the main thread so readily. Yielding is good because user interactions have the opportunity to run sooner, but it also allows other non-user interaction work to get time on the main thread too. It's a real problem—but scheduler.yield can help solve it!# Enter scheduler.yieldscheduler.yield has been available behind a flag as an experimental web platform feature since version 115 of Chrome. One question you might have is \"why do I need a special function to yield when setTimeout already does it?\"It's worth noting that yielding was not a design goal of setTimeout, but rather a nice side effect in scheduling a callback to run at a later point in the future—even with a timeout value of 0 specified. What's more important to remember, however, is that yielding with setTimeout sends remaining work to the back of the task queue. By default, scheduler.yield sends remaining work to the front of the queue. This means that work you wanted to resume immediately after yielding won't take a back seat to tasks from other sources (with the notable exception of user interactions).scheduler.yield is a function that yields to the main thread and returns a Promise when called. This means you can await it in an async function:async function yieldy () {  // Do some work...  // ...  // Yield!  await scheduler.yield();  // Do some more work...  // ...}To see scheduler.yield in action, do the following:Navigate to chrome://flags.Enable the Experimental Web Platform features experiment. You may have to restart Chrome after doing this.Navigate to the demo page or use the embedded version of it below this list.Click the top button labeled Run tasks periodically.Finally, click the button labeled Run loop, yielding with scheduler.yield on each iteration.The output in the box at the bottom of the page will look something like this:Processing loop item 1Processing loop item 2Processing loop item 3Processing loop item 4Processing loop item 5Ran blocking task via setIntervalRan blocking task via setIntervalRan blocking task via setIntervalRan blocking task via setIntervalRan blocking task via setIntervalUnlike the demo that yields using setTimeout, you can see that the loop—even though it yields after every iteration—doesn't send the remaining work to the back of the queue, but rather to the front of it. This gives you the best of both worlds: you can yield to improve input responsiveness on your website, but also ensure that the work you wanted to finish after yielding doesn't get delayed.This is a basic primer on scheduler.yield, and is meant to illustrate what benefits it provides by default. However, there are advanced ways of using it, including integration with scheduler.postTask, and the ability to yield with explicit priorities. For more information, read this in-depth explainer.# Give it a try!If scheduler.yield looks interesting to you and you want to try it out, you can do so in two ways starting in version 115 of Chrome:If you want to experiment with scheduler.yield locally, type and enter chrome://flags in Chrome's address bar and select Enable from the dropdown in the Experimental Web Platform Features section. This will make scheduler.yield (and any other experimental features) available in only your instance of Chrome.If you want to enable scheduler.yield for real Chromium users on a publicly accessible origin, you'll need to sign up for the scheduler.yield origin trial. This allows you to safely experiment with proposed features for a given period of time, and gives the Chrome Team valuable insights into how those features are used in the field. For more information on how origin trials work, read this guide.How you use scheduler.yield—while still supporting browsers that don't implement it—depends on what your goals are. You can use the official polyfill. The polyfill is useful if the following applies to your situation:You're already using scheduler.postTask in your application to schedule tasks.You want to be able to set task and yielding priorities.You want to be able to cancel or reprioritize tasks via the TaskController class the scheduler.postTask API offers.If this doesn't describe your situation, then the polyfill might not be for you. In that case, you can roll your own fallback in a couple of ways. The first approach uses scheduler.yield if it's available, but falls back to setTimeout if it isn't:// A function for shimming scheduler.yield and setTimeout:function yieldToMain () {  // Use scheduler.yield if it exists:  if ('scheduler' in window && 'yield' in scheduler) {    return scheduler.yield();  }  // Fall back to setTimeout:  return new Promise(resolve => {    setTimeout(resolve, 0);  });}// Example usage:async function doWork () {  // Do some work:  // ...  await yieldToMain();  // Do some other work:  // ...}This can work, but as you might guess, browsers that don't support scheduler.yield will yield without \"front of queue\" behavior. If that means you'd rather not yield at all, you can try another approach which uses scheduler.yield if it's available, but won't yield at all if it isn't:// A function for shimming scheduler.yield with no fallback:function yieldToMain () {  // Use scheduler.yield if it exists:  if ('scheduler' in window && 'yield' in scheduler) {    return scheduler.yield();  }  // Fall back to nothing:  return;}// Example usage:async function doWork () {  // Do some work:  // ...  await yieldToMain();  // Do some other work:  // ...}scheduler.yield is an exciting addition to the scheduler API—one that will hopefully make it easier for developers to improve responsiveness than current yielding strategies. If scheduler.yield seems like a useful API to you, please participate in our research to help improve it, and provide feedback on how it could be further improved.Hero image from Unsplash, by Jonathan Allison."
  },
  {
    "url": "https://developer.chrome.com/blog/automatic-picture-in-picture/",
    "title": "Automatic picture-in-picture for web apps",
    "blog": "With the recent introduction of the Document Picture-in-Picture API (and even before), web developers are increasingly interested in being able to automatically open a picture-in-picture window when the user switches focus from their current tab. This is especially useful for video conferencing web apps, where it allows presenters to see and interact with participants in real time while presenting a document or using other tabs or windows.  A picture-in-picture window opened and closed automatically when user switches tabs.# Enter picture-in-picture automaticallyTo support these video conferencing use cases, from Chrome 120 desktop web apps can automatically enter picture-in-picture, with a few restrictions to ensure a positive user experience. A web app is only eligible for automatic picture-in-picture if it meets all of the following conditions:It has registered a media session action handler for the \"enterpictureinpicture\" action.It is actively capturing camera or microphone via getUserMedia.The user allows \"automatic picture-in-picture\" through a browser setting enabled by default.Automatic picture-in-picture setting in Chrome browser site information pane.When a web app is eligible, the media session action handler callback function for the \"enterpictureinpicture\" action is fired when the user switches focus to another tab, allowing it to open a picture-in-picture window without a user gesture.Web developers can either use the Picture-in-Picture API for <video> to open a picture-in-picture window from an HTML <video> element, or the Document Picture-in-Picture API to open an always-on-top window to populate with arbitrary HTML content. The picture-in-picture window is not focused when opened and automatically closed when the page visibility becomes visible again.The following example shows you how to request access to the user’s camera. Then, safely register a media session action handler for the \"enterpictureinpicture\" action with a callback function that opens a picture-in-picture window. This window contains the user’s camera video stream with the Picture-in-Picture API for <video>.const video = document.querySelector(\"video\");// Request access to the user's camera.navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {  video.srcObject = stream;});try {  // Request video to automatically enter picture-in-picture when eligible.  navigator.mediaSession.setActionHandler(\"enterpictureinpicture\", () => {    video.requestPictureInPicture();  });} catch (error) {  console.log(\"The enterpictureinpicture action is not yet supported.\");}Try the Video Conferencing Media Session sample.# Enter picture-in-picture from browser media controlThe \"enterpictureinpicture\" media session action is also useful when the user wants to enter picture-in-picture using the media control in the Chrome browser UI.Media control in Chrome browser, with the cursor on picture-in-picture user control.When there is no HTML <video> element playing but only audio, registering the media session action handler for \"enterpictureinpicture\" tells the browser that the web app knows how to handle it and will take care of opening a picture-in-picture window itself.It is also useful when the web app wants to use the Document Picture-in-Picture API to open a picture-in-picture window instead of letting the browser handling it with the Picture-in-Picture API for <video>.The following example demonstrates how to safely register a media session action handler for the \"enterpictureinpicture\" action. The callback function opens a picture-in-picture window with the Document Picture-in-Picture API when the user enters picture-in-picture using the media control in the Chrome browser UI.try {  // Use the Document Picture-in-Picture API when entering  // picture-in-picture from browser media control.  navigator.mediaSession.setActionHandler(\"enterpictureinpicture\", async () => {    const pipWindow = await documentPictureInPicture.requestWindow();    // Populate HTML content and handle closing window...  });} catch (error) {  console.log(\"The enterpictureinpicture action is not yet supported.\");}Try the Document Picture-in-Picture API VideoJS player demo or the Video Media Session sample.# Engage and share feedbackIf you have feedback or encounter any issues, you can share them at crbug.com.# ResourcesSpec changesChromeStatus entryIntent to Ship# AcknowledgmentsThanks to Tommy Steimel, Ryan Flores, Shimi Rahim, Frank Liberato, and Rachel Andrew for their reviews.Hero image by pine watt on Unsplash."
  },
  {
    "url": "https://developer.chrome.com/blog/third-party-cookie-deprecation-trial/",
    "title": "Request additional migration time with the third-party cookie deprecation trial",
    "blog": "Chrome plans to disable third-party cookies for 1% of users starting in early Q1 2024 with the eventual goal of ramping up to 100% starting in Q3 2024, subject to resolving any competition concerns with the UK’s Competition and Markets Authority (CMA). For an easier transition through the deprecation process, we are offering a third-party deprecation trial which allows embedded sites and services to request additional time to migrate away from third-party cookie dependencies for non-advertising use cases.Third-party origin trials enable providers of embedded content or services to access a trial feature across multiple sites, by using JavaScript to provide a trial token. To request a third-party token when registering, enable the \"Third-party matching\" option on the origin trial's registration page. A third-party token must be provided by using JavaScript to write an origin trial meta tag, not in HTML code or an HTTP header.Deprecation trials enable a deprecated feature to be temporarily re-enabled. Participation in this deprecation trial allows third-party cookies to be temporarily re-enabled.Registration for this deprecation trial is intended to start the week of November 27, 2023. The deprecation trial will officially start in January 2024 and end on December 27, 2024. Developers are expected to make necessary changes and plans by this trial end date.# Deprecation trialsDeprecation trials are a standard option that Chrome provides to allow sites to register for additional time to migrate away from the legacy functionality being removed. A deprecation trial is a type of origin trial that allows a feature to be temporarily re-enabled.This trial is for the embeds and services that set third-party cookies and that meet our below outlined eligibility criteria. In other words, if your embed or service is the third party, then you can register for the deprecation trial to temporarily re-enable your third-party cookies in all contexts where your embed or service is included. The trial only applies to the registered embedded origin and not the entire top level site domain that users visit.Top-level sites that use third parties that rely on cookies do not need to sign up for this deprecation trial. You should audit the third-party cookies used within your site and contact your third-party providers to ensure they are prepared for the deprecation.# Eligibility criteria and review processThis deprecation trial differs from previous trials with the introduction of a review and approval process for participation. This is to strike a balance between improving privacy for people on the web, while still enabling the services they depend on to request extra time to migrate if necessary.The principles guiding this deprecation trial are:Preserving user-critical functionality: This deprecation trial is intended for third-party providers that demonstrate functional breakage in user journeys.Limiting user tracking: The deprecation trial is not intended to support cross-site tracking for advertising purposes, and as such third-party embeds and services used for advertising are not eligible.The ineligibility of advertising use cases will also help to ensure the deprecation trial does not interfere with the industry testing planned for the start of 2024 as described by the Competition and Markets Authority. This includes advertising-related domains that are also used for non-advertising purposes.Chrome will initially work with Disconnect.me, an industry leader in internet privacy, and implement Disconnect's tracker protection lists to identify the scripts and domains categorized as advertising. Disconnect is already used by other browsers for similar purposes on the web.We will apply the following process for registration requests:If the third-party origin matches a known advertising domain, including if the origin matches an entry on the Disconnect advertising list, then the registration request will be rejected. In general, entries on the list will match all subdomains below the specified origin. Some entries, however, include a path element. These more specific entries will match the given origin, but not subdomains.Steps to reproduce a broken user-facing experience must be provided. In particular, this should be an experience for the user operating the device where the cookie is stored, and not a user performing later analysis of data. If we cannot validate a broken user experience then the registration request will be rejected.Otherwise the registration request will be approved.We plan to offer an appeals process if the registering origin believes more information could clarify a review decision. The registrant can request an appeal by reapplying on the OT console. The intent of appeals is for requests that were rejected due to missing the requested information (known breakage bug and/or breakage repro steps) and/or if the registering origin believes more information could satisfy these requirements to clarify a review decision.# Apply for the deprecation trialBefore applying, you must report the functionality that will be broken by the third-party cookie deprecation, at goo.gle/report-3pc-broken.Include reproduction steps that our team can use to verify the functional breakage. Alternatively if it’s easier and/or your functionality is gated by login or similar, you can provide a link to a recording of the steps to reproduce the problem, using Chrome DevTools Recorder.Starting the week of November 27, 2023 navigate to the \"3PCD Deprecation Trial\" via the list of Active Trials on the Chrome Origin Trials page and click \"Register\".For \"Web Origin\", provide the origin which serves your embedded page or scripts.The \"Third-party matching\" option will depend on how you need to provide the token. The options are explained in more detail in Add the trial token.If you are providing the token via HTTP header or meta tag on your own embedded pages, do not check \"Third-party matching\".If you are injecting the token via JavaScript into a different site, you must check \"Third-party matching\".If you need to do both, you will need to make separate registrations.If you host cross-site content across multiple subdomains, then check the \"match all subdomains\" option.Tokens will match multiple subdomains similarly to wildcard matching, e.g. *.<domain>. Request a token for example.com and it can be provided on a.example.com, b.example.com. Third-party cookie access will still only be re-enabled for the specific origins that provide the token, not all the subdomains. See What cookies are enabled when subdomain matching is enabled?.If you host cross-site content across separate origins that are not under the same domain, you will need to make separate registrations for each origin.Acknowledge all conditions included in ‘Disclosure and Acknowledgement’ by checking all boxes.Submit the request.We require additional information to process your request. You will receive an email notification with an auto-generated ticket asking for the following:The number of subdomains tied to your requested originThe bug ID or link for the associated third-party breakage repo bugs that you previously reported to goo.gle/report-3pc-broken.Any additional information/context about the breakage/use case that you would like us to consider. (In cases of an appeal for a denied trial request, explain why/how your origin meets the outlined criteria for this trial).Once submitted, we will review your request and notify you when review is complete or if additional information is needed, and whether your request is either approved or denied. You will also receive the status and rationale for the result. If approved, you can proceed to provide the trial token as needed. If denied, you can follow the guidance in the request ticket.# Add the trial tokenRefer to Get started with origin trials, Third-party origin trials, and Troubleshoot Chrome origin trials for more details.You should include the trial token in all page responses where you want to set or send cookies in a cross-site context.If your embedded resource is a third-party iframe, then you can provide a token using an HTTP origin-trial header, an HTML <meta> tag, or via JavaScript. If your embedded resource is a third-party script, follow the steps outlined in Inject the token via JavaScript. If your embedded resource is neither of those — for example, it's just a pixel loaded via an <img> tag — then neither of these techniques will work, and you will need to ask the embedding first party to include a <meta> tag with your token on your behalf.# Provide the token via HTTP headerIf you need to re-enable third-party cookies for a page embedded within a cross-site iframe, you can include the Origin-Trial HTTP header in the page response:Origin-Trial: TOKEN_GOES_HEREThis corresponds to not enabling \"Third-party matching\" in your deprecation trial registration as you are providing the token in your own responses.That page response can set a cookie. Subsequent requests to that same origin, such as sub-resources in that page or navigations from that page will include the site's cross-site cookies and may also set cookies.If you need cross-site cookies to be on the very first request to your origin in the session, then you can also use Critical-Origin-Trial header passing the trial name:Critical-Origin-Trial: TpcdThis will cause the browser to retry the request with third-party cookies enabled.The deprecation trial is provided as a persistent trial, which means that once the token has been received by the browser, the trial behavior will be applied until an iframe is loaded without a trial token present. It is recommended to send the trial token on each iframe load consistently.# Provide the token via meta tagWithin a page, you can use a meta tag in the document <head>:<meta http-equiv=\"origin-trial\" content=\"TOKEN_GOES_HERE\">The meta tag will enable cross-site cookies for subsequent requests or JavaScript in the page, but you will need to use the HTTP header if you require existing cookies to be sent on the initial request.# Inject the token via JavaScriptIf you need to enable third-party cookies for your origin before or without serving your own page request, for example, if cookies are required on a cross-site image request, or you intend to create an iframe via JavaScript, then you can inject the token into the top-level site using JavaScript:const otMeta = document.createElement('meta');otMeta.httpEquiv = 'origin-trial';otMeta.content = 'TOKEN_GOES_HERE';document.head.append(otMeta);To allow this, you must enable \"Third-party matching\" in your deprecation trial registration as you are injecting the token for your origin (the third-party) into a different site.A token with third-party matching enabled may be injected on any origin, including your own, and it will work.A persistent trial will still be disabled if an iframe is loaded without the trial token. You must consistently provide the trial token on all iframes loaded even if the trial was enabled via a third-party script load originally.# Validate your tokenOpen DevTools and navigate to the Application tab. Expand the Frames tree in the left-hand navigation. Selecting any frame will show an Origin Trials section if any tokens have been provided. If you are injecting the token into the top-level site, you will see this on the \"top\" entry. Otherwise you should select the frame that corresponds to your embedded page.In the Origin Trials section, if you have provided a token you should see an entry for \"Tpcd\". If this has successfully enabled the feature, you will see a green \"Enabled\" status. Otherwise you will see a red error status and you can expand the entry to see the problem.Only one valid token is needed to activate the deprecation trial. If you have registered for both first-party and third-party matching, it is not an issue if you provide both tokens within the page. For example, if you have a single page that may be embedded in different ways, then you do not need to dynamically choose a token, you can simply provide both and the trial will be enabled in either context.# What cookies are enabled?The deprecation trial only enables third-party cookies for the origin registered for the trial. After activation third-party cookies will be present on iframe and subresource requests to that origin. Third-party cookies will also be available via document.cookie in iframes with that origin as well.Learn about the difference between sites and origins in Understanding \"same-site\" and \"same-origin\"Cookie Domain attributes are not considered here. Only the request URL origin is considered. Once a request is determined to have third-party cookies all such cookies will be attached as normal even if the domain of a cookie is more permissive.For example, if https://one.test.example is registered and its token is provided in an https://one.test.example iframe:https://one.test.example/image.jpg will receive cookies set from https://one.test.examplehttps://one.test.example/image.jpg will receive cookies set from other origins with Domain=.test.examplehttps://test.example/image.jpg or https://two.test.example/image.jpg requests will not receive third-party cookies because they are not same-origin.# What cookies are enabled when subdomain matching is enabled?The \"match all subdomains\" option allows a single token to be used on the registration origin or any origin with a more specific subdomain. A token for https://test.example with subdomain matching can be used to activate the trial via https://test.example, https://one.test.example, or https//two.test.example iframes and third-party script loads.In addition, when subdomain matching is enabled, third-party cookies will also be available on requests and in iframes associated with corresponding subdomains. For example, if https://test.example uses subdomain matching, subresource requests like https://cdn.one.test.example/image.jpg will receive third-party cookies.Trial deactivation does not take subdomain matching into account. To deactivate the trial an iframe exactly matching the origin in the registration must be loaded without a token. So a registration for https://test.example with subdomain matching can only be disabled by an https://test.example iframe without a token. This may change in the future, so we recommend providing a token on all subframe iframes when you want to enable the trial and removing tokens from all iframes when you want to deactivate the trial.# Frequently Asked QuestionsWhat if I have questions about the Disconnect.me list?Contact Disconnect at support@disconnect.me as we do not manage the Disconnect list. For more information, see their tracker protection page.Can I register for the deprecation trial if my domain is used for both advertising and non-advertising purposes?Third-party embeds and services used for advertising are not eligible for the deprecation trial, for the reasons explained in this blog previously. This includes advertising-related domains that are also used for non-advertising purposes. For more information, see the Eligibility criteria and review process section.Will sites be able to see which one of their partners have enrolled in the deprecation trial? Will they be able to limit the registration across their partners?Yes, sites can see which embeds and services are relying on a deprecation trial token via the application panel in Chrome Devtools. See Troubleshoot Chrome origin trials for more information.Top level sites won’t be able to limit registration across their partners or the embeds and services on their page. Contact the partner if that is desired.How is this trial different from other trials such as the User-Agent reduction origin trial?The main way this deprecation trial is different is the new registration process that involves meeting the participation criteria and the new UI/pages in the OT console.The second way this is different is that it is exclusively for third-party embedded sites to resolve the maximum amount of web compatibility issues across a number of sites/service clients.Will there be a first-party deprecation trial for third-party cookie deprecation that top level sites can enroll in to enable 3PCs for their entire site?At the moment we are focusing on third-party embeds and services. We recommend first-party sites continue making changes to their sites directly to fix the breakage and encourage their embedded third parties to sign up for this deprecation trial.How long will it take to review my deprecation trial application? Where can I check on the status of my application?Response times may vary; you are encouraged to begin the registration process as soon as possible to ensure you will be ready ahead of 1% third-party cookie deprecation in early Q1. If you have not received any response within 1-2 weeks of submitting your registration, please contact 3pc-deprecationtrial@google.com.Bug thread for open conversation, decision status and rationale.Our deprecation trial registration has been approved, and we've deployed a trial token as recommended. However, the deprecation trial isn't working as expected. What should we do?Troubleshoot Chrome origin trials provides a checklist for troubleshooting origin trials. In particular, for this deprecation trial, make sure you have registered for the correct origin, opted for a third-party token if necessary, and correctly provided the token via an HTTP header, meta tag or (for a third-party token) using JavaScript. You can learn more about third-party origin trials at Third-party origin trials, and there is a deprecation trial demo at Chrome origin trial demo: Token injected by third-party script. If you continue to experience problems, contact origin-trials-support@google.com."
  }
]